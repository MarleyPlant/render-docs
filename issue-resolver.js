import fs from "fs"
import path from "path"
import OpenAI from 'openai'
import { findImplementationFile } from "./helpers.js"

const MODEL_NAME = "gpt-3.5-turbo"

class IssueResolver {
    constructor(messages, apiKey) {
        if(!apiKey) throw new Error("No OpenAI API key provided")
        
        this.openai = new OpenAI({
            apiKey: apiKey
        });

        this.messages = this.groupMessagesByFile(messages)
    }
    
    groupMessagesByFile(messages){
        return messages.reduce((accumulator, message) => {
            // Messages are in the format "file:line: warning: message"
            const [file, line, warning, ...rest] = message.split(":")
            const key = `${file}`
            if(!accumulator[key]) accumulator[key] = []
            accumulator[key].push(`${line}: ${rest.join(":").trim()}`)
            return accumulator
        }, {})
    }

    constructPrompt(file, messages, includeImplementationFile = true){
        const fileContents = fs.readFileSync(file).toString()
        const implementationFile = findImplementationFile(file)
        let implementationFileContents
        if(implementationFile && includeImplementationFile){
            implementationFileContents = fs.readFileSync(implementationFile).toString()
        }
        const filename = path.basename(file)
        const promptIntro = `There are issues with the documentation in a C++ file (${filename}):\n\n\`\`\`cpp\n${fileContents}\n\`\`\``
        const promptWarnings = `The following warnings are generated by doxygen. They are in the format 'line: warning': \n\n\`\`\`\n${messages.join("\n")}\n\`\`\``
        const promptImplementation = implementationFileContents ? `Here is the corresponding implementation file for reference:\n\n\`\`\`cpp\n${implementationFileContents}\n\`\`\`` : ""
        const promptImplementationHint = implementationFileContents ? ` When adding missing documentation, consult the implementation file to enhance quality and usefulness.` : ""
        const promptOutro = `Please fix the issues. Don't touch the code itself.${promptImplementationHint} Print the whole file (${filename}) including those fixes as a code block without any extra text or explanations.`
        const constructedPrompt = `${promptIntro}\n\n${promptWarnings}\n\n${promptImplementation}\n\n${promptOutro}`
        return constructedPrompt
    }

    extractCodeBlock(response){
        // Remove anything that comes before the first code block denoted by ``` if there is one
        // ChatGPT sometimes adds extra text before the code block
        const codeBlockIndex = response.indexOf("```")
        const result = codeBlockIndex > 0 ? response.substring(codeBlockIndex) : response
        // Strip ```cpp from the beginning and end
        return result.replace("```cpp\n", "").replace("```", "")
    }


    async getResolvedFile(file){
        const messages = this.messages[file]
        const prompt = this.constructPrompt(file, messages)
        try {
            console.log(`ü§ñ Asking AI to resolve issues in file ${file}. This may take a while...`)
            const chatCompletion = await this.openai.chat.completions.create({
                messages: [{ role: 'user', content: prompt }],
                model: MODEL_NAME,
            });
            const response = chatCompletion.choices[0].message.content
            return this.extractCodeBlock(response)
        } catch (error) {
            if(error.code === "rate_limit_exceeded"){
                console.error("‚ùå Rate limit exceeded. Please try again later.")
                return null
            }
            if(error.code === "context_length_exceeded"){
                console.error("‚ùå Context length exceeded. Consider splitting the file into multiple files.")
                return null
            }
            console.error(`‚ùå Error resolving issues in file ${file}. ${error.message}`)
            return null
        }
    }

    async resolve() {
        let result = true

        for (const file of Object.keys(this.messages)) {
            const resolvedFile = await this.getResolvedFile(file)
            if(resolvedFile){
                fs.writeFileSync(file, resolvedFile)
            } else {
                result = false
            }
        }
        return result
    }
}

export default IssueResolver